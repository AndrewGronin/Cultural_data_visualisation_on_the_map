// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var welcome = Welcome.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Welcome
    {
        [JsonProperty("data")]
        public Data Data { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("persons")]
        public PersonElement[] Persons { get; set; }
    }

    public partial class PersonElement
    {
        [JsonProperty("firstName")]
        public Description FirstName { get; set; }

        [JsonProperty("lastName")]
        public Description LastName { get; set; }

        [JsonProperty("pseudonym")]
        public Description Pseudonym { get; set; }

        [JsonProperty("profession")]
        public Description Profession { get; set; }

        [JsonProperty("description")]
        public Description Description { get; set; }

        [JsonProperty("birthDate")]
        public string BirthDate { get; set; }

        [JsonProperty("deathDate")]
        public string DeathDate { get; set; }

        [JsonProperty("relations")]
        public Relation[] Relations { get; set; }
    }

    public partial class Description
    {
        [JsonProperty("en")]
        public string En { get; set; }

        [JsonProperty("ru")]
        public string Ru { get; set; }
    }

    public partial class Relation
    {
        [JsonProperty("quote")]
        public Description Quote { get; set; }

        [JsonProperty("person")]
        public RelationPerson Person { get; set; }

        [JsonProperty("location")]
        public Location Location { get; set; }
    }

    public partial class Location
    {
        [JsonProperty("name")]
        public Description Name { get; set; }

        [JsonProperty("description")]
        public Description Description { get; set; }

        [JsonProperty("coordinateX")]
        public double? CoordinateX { get; set; }

        [JsonProperty("coordinateY")]
        public double? CoordinateY { get; set; }

        [JsonProperty("constructionDate")]
        public string ConstructionDate { get; set; }

        [JsonProperty("demolitionDate")]
        public DemolitionDateUnion DemolitionDate { get; set; }

        [JsonProperty("wikiLink")]
        public WikiLinkUnion WikiLink { get; set; }

        [JsonProperty("photoLinks")]
        public string PhotoLinks { get; set; }

        [JsonProperty("mainPhotoLink")]
        public string MainPhotoLink { get; set; }
    }

    public partial class RelationPerson
    {
        [JsonProperty("firstName")]
        public Description FirstName { get; set; }

        [JsonProperty("lastName")]
        public Description LastName { get; set; }

        [JsonProperty("pseudonym")]
        public Description Pseudonym { get; set; }

        [JsonProperty("profession")]
        public Description Profession { get; set; }

        [JsonProperty("description")]
        public Description Description { get; set; }

        [JsonProperty("birthDate")]
        public string BirthDate { get; set; }

        [JsonProperty("deathDate")]
        public string DeathDate { get; set; }
    }

    public enum DemolitionDateEnum { DemolitionDate, Empty, The041740, The1930Е, The1932, The19321939, The194, The1940Е, The1960Е, The2019, The3Марта1915, Середина1960Х };

    public enum WikiLinkEnum { Empty, WwwCitywallsRuHouse7476Html };

    public partial struct DemolitionDateUnion
    {
        public DemolitionDateEnum? Enum;
        public long? Integer;

        public static implicit operator DemolitionDateUnion(DemolitionDateEnum Enum) => new DemolitionDateUnion { Enum = Enum };
        public static implicit operator DemolitionDateUnion(long Integer) => new DemolitionDateUnion { Integer = Integer };
    }

    public partial struct WikiLinkUnion
    {
        public WikiLinkEnum? Enum;
        public Uri PurpleUri;

        public static implicit operator WikiLinkUnion(WikiLinkEnum Enum) => new WikiLinkUnion { Enum = Enum };
        public static implicit operator WikiLinkUnion(Uri PurpleUri) => new WikiLinkUnion { PurpleUri = PurpleUri };
    }

    public partial class Welcome
    {
        public static Welcome FromJson(string json) => JsonConvert.DeserializeObject<Welcome>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DemolitionDateUnionConverter.Singleton,
                DemolitionDateEnumConverter.Singleton,
                WikiLinkUnionConverter.Singleton,
                WikiLinkEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DemolitionDateUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DemolitionDateUnion) || t == typeof(DemolitionDateUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.Empty };
                        case "04.1740":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The041740 };
                        case "1930-е":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The1930Е };
                        case "1932 ":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The1932 };
                        case "1932-1939":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The19321939 };
                        case "1940-е":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The1940Е };
                        case "194?":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The194 };
                        case "1960-е":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The1960Е };
                        case "2019(?)":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The2019 };
                        case "3 марта 1915":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.The3Марта1915 };
                        case "?":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.DemolitionDate };
                        case "середина 1960-х":
                            return new DemolitionDateUnion { Enum = DemolitionDateEnum.Середина1960Х };
                    }
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return new DemolitionDateUnion { Integer = l };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type DemolitionDateUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DemolitionDateUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case DemolitionDateEnum.Empty:
                        serializer.Serialize(writer, "");
                        return;
                    case DemolitionDateEnum.The041740:
                        serializer.Serialize(writer, "04.1740");
                        return;
                    case DemolitionDateEnum.The1930Е:
                        serializer.Serialize(writer, "1930-е");
                        return;
                    case DemolitionDateEnum.The1932:
                        serializer.Serialize(writer, "1932 ");
                        return;
                    case DemolitionDateEnum.The19321939:
                        serializer.Serialize(writer, "1932-1939");
                        return;
                    case DemolitionDateEnum.The1940Е:
                        serializer.Serialize(writer, "1940-е");
                        return;
                    case DemolitionDateEnum.The194:
                        serializer.Serialize(writer, "194?");
                        return;
                    case DemolitionDateEnum.The1960Е:
                        serializer.Serialize(writer, "1960-е");
                        return;
                    case DemolitionDateEnum.The2019:
                        serializer.Serialize(writer, "2019(?)");
                        return;
                    case DemolitionDateEnum.The3Марта1915:
                        serializer.Serialize(writer, "3 марта 1915");
                        return;
                    case DemolitionDateEnum.DemolitionDate:
                        serializer.Serialize(writer, "?");
                        return;
                    case DemolitionDateEnum.Середина1960Х:
                        serializer.Serialize(writer, "середина 1960-х");
                        return;
                }
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value.ToString());
                return;
            }
            throw new Exception("Cannot marshal type DemolitionDateUnion");
        }

        public static readonly DemolitionDateUnionConverter Singleton = new DemolitionDateUnionConverter();
    }

    internal class DemolitionDateEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DemolitionDateEnum) || t == typeof(DemolitionDateEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return DemolitionDateEnum.Empty;
                case "04.1740":
                    return DemolitionDateEnum.The041740;
                case "1930-е":
                    return DemolitionDateEnum.The1930Е;
                case "1932 ":
                    return DemolitionDateEnum.The1932;
                case "1932-1939":
                    return DemolitionDateEnum.The19321939;
                case "1940-е":
                    return DemolitionDateEnum.The1940Е;
                case "194?":
                    return DemolitionDateEnum.The194;
                case "1960-е":
                    return DemolitionDateEnum.The1960Е;
                case "2019(?)":
                    return DemolitionDateEnum.The2019;
                case "3 марта 1915":
                    return DemolitionDateEnum.The3Марта1915;
                case "?":
                    return DemolitionDateEnum.DemolitionDate;
                case "середина 1960-х":
                    return DemolitionDateEnum.Середина1960Х;
            }
            throw new Exception("Cannot unmarshal type DemolitionDateEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DemolitionDateEnum)untypedValue;
            switch (value)
            {
                case DemolitionDateEnum.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case DemolitionDateEnum.The041740:
                    serializer.Serialize(writer, "04.1740");
                    return;
                case DemolitionDateEnum.The1930Е:
                    serializer.Serialize(writer, "1930-е");
                    return;
                case DemolitionDateEnum.The1932:
                    serializer.Serialize(writer, "1932 ");
                    return;
                case DemolitionDateEnum.The19321939:
                    serializer.Serialize(writer, "1932-1939");
                    return;
                case DemolitionDateEnum.The1940Е:
                    serializer.Serialize(writer, "1940-е");
                    return;
                case DemolitionDateEnum.The194:
                    serializer.Serialize(writer, "194?");
                    return;
                case DemolitionDateEnum.The1960Е:
                    serializer.Serialize(writer, "1960-е");
                    return;
                case DemolitionDateEnum.The2019:
                    serializer.Serialize(writer, "2019(?)");
                    return;
                case DemolitionDateEnum.The3Марта1915:
                    serializer.Serialize(writer, "3 марта 1915");
                    return;
                case DemolitionDateEnum.DemolitionDate:
                    serializer.Serialize(writer, "?");
                    return;
                case DemolitionDateEnum.Середина1960Х:
                    serializer.Serialize(writer, "середина 1960-х");
                    return;
            }
            throw new Exception("Cannot marshal type DemolitionDateEnum");
        }

        public static readonly DemolitionDateEnumConverter Singleton = new DemolitionDateEnumConverter();
    }

    internal class WikiLinkUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WikiLinkUnion) || t == typeof(WikiLinkUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "":
                            return new WikiLinkUnion { Enum = WikiLinkEnum.Empty };
                        case "www.citywalls.ru/house7476.html":
                            return new WikiLinkUnion { Enum = WikiLinkEnum.WwwCitywallsRuHouse7476Html };
                    }
                    try
                    {
                        var uri = new Uri(stringValue);
                        return new WikiLinkUnion { PurpleUri = uri };
                    }
                    catch (UriFormatException) { }
                    break;
            }
            throw new Exception("Cannot unmarshal type WikiLinkUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (WikiLinkUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case WikiLinkEnum.Empty:
                        serializer.Serialize(writer, "");
                        return;
                    case WikiLinkEnum.WwwCitywallsRuHouse7476Html:
                        serializer.Serialize(writer, "www.citywalls.ru/house7476.html");
                        return;
                }
            }
            if (value.PurpleUri != null)
            {
                serializer.Serialize(writer, value.PurpleUri.ToString());
                return;
            }
            throw new Exception("Cannot marshal type WikiLinkUnion");
        }

        public static readonly WikiLinkUnionConverter Singleton = new WikiLinkUnionConverter();
    }

    internal class WikiLinkEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WikiLinkEnum) || t == typeof(WikiLinkEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return WikiLinkEnum.Empty;
                case "www.citywalls.ru/house7476.html":
                    return WikiLinkEnum.WwwCitywallsRuHouse7476Html;
            }
            throw new Exception("Cannot unmarshal type WikiLinkEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WikiLinkEnum)untypedValue;
            switch (value)
            {
                case WikiLinkEnum.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case WikiLinkEnum.WwwCitywallsRuHouse7476Html:
                    serializer.Serialize(writer, "www.citywalls.ru/house7476.html");
                    return;
            }
            throw new Exception("Cannot marshal type WikiLinkEnum");
        }

        public static readonly WikiLinkEnumConverter Singleton = new WikiLinkEnumConverter();
    }
}
